/**
 * Research Output Formatter
 *
 * Generates polished markdown documents from research results.
 */

import type { ResearchResult, ResearchFinding, SourceReference } from './types.js';

/**
 * Format a research result into a markdown document
 */
export function formatResearchMarkdown(result: ResearchResult): string {
  const lines: string[] = [];

  // Header
  lines.push(`# Research: ${result.query}`);
  lines.push('');
  lines.push(`> Generated by Matrix Deep Research on ${result.generatedAt}`);
  lines.push(`> Depth: ${result.depth} | Sources: ${result.sources.length}`);
  lines.push('');

  // Summary
  lines.push('## Summary');
  lines.push('');
  lines.push(result.summary);
  lines.push('');

  // Key Findings
  if (result.findings.length > 0) {
    lines.push('## Key Findings');
    lines.push('');

    for (const finding of result.findings) {
      lines.push(`### ${finding.topic}`);
      lines.push('');
      lines.push(finding.content);
      lines.push('');

      // Code examples for this finding
      if (finding.codeExamples && finding.codeExamples.length > 0) {
        for (const example of finding.codeExamples) {
          if (example.description) {
            lines.push(`**${example.description}:**`);
            lines.push('');
          }
          lines.push(`\`\`\`${example.language}`);
          lines.push(example.code);
          lines.push('```');
          lines.push('');
        }
      }
    }
  }

  // Best Practices
  if (result.bestPractices.length > 0) {
    lines.push('## Best Practices');
    lines.push('');
    for (const practice of result.bestPractices) {
      lines.push(`- ${practice}`);
    }
    lines.push('');
  }

  // Common Pitfalls
  if (result.pitfalls.length > 0) {
    lines.push('## Common Pitfalls');
    lines.push('');
    for (const pitfall of result.pitfalls) {
      lines.push(`- ${pitfall}`);
    }
    lines.push('');
  }

  // Sources
  if (result.sources.length > 0) {
    lines.push('## Sources');
    lines.push('');
    const uniqueSources = deduplicateSources(result.sources);
    for (let i = 0; i < uniqueSources.length; i++) {
      const source = uniqueSources[i]!;
      const num = i + 1;
      if (source.url) {
        lines.push(`${num}. [${source.title}](${source.url}) - ${source.type}`);
      } else {
        lines.push(`${num}. ${source.title} - ${source.type}`);
      }
    }
    lines.push('');
  }

  // Footer
  lines.push('---');
  lines.push(`*Token estimate: ~${result.tokenEstimate.toLocaleString()}*`);

  return lines.join('\n');
}

/**
 * Generate a slug from a query for file naming
 */
export function slugify(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '')
    .slice(0, 50);
}

/**
 * Generate a filename for research output
 */
export function generateFilename(query: string): string {
  const slug = slugify(query);
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
  return `matrix-research-${slug}-${timestamp}.md`;
}

/**
 * Get the default output path for research documents
 */
export function getDefaultOutputPath(): string {
  const home = process.env.HOME || process.env.USERPROFILE || '~';
  return `${home}/Downloads`;
}

/**
 * Deduplicate sources by URL
 */
function deduplicateSources(sources: SourceReference[]): SourceReference[] {
  const seen = new Set<string>();
  return sources.filter(source => {
    const key = source.url || source.title;
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });
}

/**
 * Format a single finding as markdown
 */
export function formatFinding(finding: ResearchFinding): string {
  const lines: string[] = [];

  lines.push(`### ${finding.topic}`);
  lines.push('');
  lines.push(finding.content);
  lines.push('');

  if (finding.codeExamples && finding.codeExamples.length > 0) {
    for (const example of finding.codeExamples) {
      if (example.description) {
        lines.push(`**${example.description}:**`);
      }
      lines.push(`\`\`\`${example.language}`);
      lines.push(example.code);
      lines.push('```');
      lines.push('');
    }
  }

  return lines.join('\n');
}

/**
 * Format sources as a numbered list
 */
export function formatSourceList(sources: SourceReference[]): string {
  return deduplicateSources(sources)
    .map((source, i) => {
      const num = i + 1;
      if (source.url) {
        return `${num}. [${source.title}](${source.url})`;
      }
      return `${num}. ${source.title}`;
    })
    .join('\n');
}

/**
 * Estimate token count for a string (rough approximation)
 */
export function estimateTokens(text: string): number {
  // Rough estimate: ~4 characters per token
  return Math.ceil(text.length / 4);
}

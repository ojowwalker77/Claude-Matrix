/**
 * Base Scheduler - Abstract Class for Platform Schedulers
 *
 * Provides common functionality for platform-specific scheduler implementations.
 * Handles command generation, worktree script generation, and shared utilities.
 */

import type { DreamerTask, SchedulerStatus } from '../types.js';
import { shellEscape, sanitizeForComment } from './shell.js';
import { getConfig } from '../../config/index.js';

/**
 * Abstract base class for platform-specific schedulers
 */
export abstract class BaseScheduler {
  /**
   * Human-readable name of the scheduler
   */
  abstract readonly name: string;

  /**
   * Platform identifier
   */
  abstract readonly platform: 'darwin' | 'linux';

  /**
   * Register a task with the native scheduler
   */
  abstract register(task: DreamerTask): Promise<void>;

  /**
   * Unregister a task from the native scheduler
   */
  abstract unregister(taskId: string): Promise<void>;

  /**
   * Check if a task is registered
   */
  abstract isRegistered(taskId: string): Promise<boolean>;

  /**
   * Get current scheduler status
   */
  abstract getStatus(): Promise<SchedulerStatus>;

  /**
   * List all registered task IDs
   */
  abstract listRegistered(): Promise<string[]>;

  /**
   * Generate the command to execute Claude in non-interactive mode
   *
   * Security: Uses single quotes for the prompt to prevent shell expansion
   * of backticks, $(), and other shell metacharacters.
   */
  protected getExecutionCommand(task: DreamerTask): string {
    const command = task.command;

    // Use shellEscape to wrap in single quotes (prevents all shell expansion)
    const escapedCommand = shellEscape(command);

    // Build the claude command
    // Note: timeout is handled by the native scheduler, not Claude CLI
    // The -p flag enables non-interactive print mode
    const flags: string[] = [];
    if (task.skipPermissions) {
      flags.push('--dangerously-skip-permissions');
    }

    const flagStr = flags.length > 0 ? ` ${flags.join(' ')}` : '';
    return `claude -p ${escapedCommand}${flagStr}`;
  }

  /**
   * Get the working directory for a task
   */
  protected getWorkingDirectory(task: DreamerTask): string {
    return task.workingDirectory || '.';
  }

  /**
   * Get the task label/identifier for the native scheduler
   */
  protected getTaskLabel(taskId: string): string {
    return `com.claude.dreamer.${taskId}`;
  }

  /**
   * Check if task uses worktree execution
   */
  protected usesWorktree(task: DreamerTask): boolean {
    return task.worktreeEnabled === true;
  }

  /**
   * Generate a shell script for git worktree-based execution
   * Returns null if worktree is not enabled
   *
   * Security: All user-provided values are escaped using shellEscape()
   * to prevent command injection attacks.
   */
  protected generateWorktreeScript(task: DreamerTask, logDir: string): string | null {
    if (!task.worktreeEnabled) {
      return null;
    }

    // Escape all user-provided values for safe shell embedding
    const config = getConfig();
    const defaultPrefix = config.dreamer.worktree.defaultBranchPrefix;
    const defaultRemote = config.dreamer.worktree.defaultRemote;

    const mainRepoEsc = shellEscape(this.getWorkingDirectory(task));
    const taskIdEsc = shellEscape(task.id);
    const taskNameEsc = shellEscape(task.name);
    const branchPrefixEsc = shellEscape(task.worktreeBranchPrefix || defaultPrefix);
    const remoteNameEsc = shellEscape(task.worktreeRemote || defaultRemote);
    const logDirEsc = shellEscape(logDir);

    // Sanitize task name for comment (strip anything that could break comment)
    const commentSafeName = sanitizeForComment(task.name);

    // Base path handling - either escaped user value or computed default
    const basePathLine = task.worktreeBasePath
      ? `WORKTREE_BASE=${shellEscape(task.worktreeBasePath)}`
      : 'WORKTREE_BASE="$(dirname "$MAIN_REPO")/.$(basename "$MAIN_REPO")-worktrees"';

    // The command is already formatted for shell execution by getExecutionCommand()
    // It handles escaping of the user prompt. We embed it directly as a command.
    const command = this.getExecutionCommand(task);

    return `#!/bin/bash
set -e

# Task: ${commentSafeName} (${task.id})
# Generated by Claude Matrix Dreamer

MAIN_REPO=${mainRepoEsc}
TASK_ID=${taskIdEsc}
TASK_NAME=${taskNameEsc}
TIMESTAMP=$(date +%s)
WORKTREE_NAME="task-\${TASK_ID:0:8}-\$TIMESTAMP"
BRANCH_PREFIX=${branchPrefixEsc}
REMOTE=${remoteNameEsc}
LOG_DIR=${logDirEsc}

# Resolve main repo to absolute path
if [[ ! "$MAIN_REPO" = /* ]]; then
  MAIN_REPO="$(pwd)/$MAIN_REPO"
fi
MAIN_REPO=$(cd "$MAIN_REPO" && pwd)

# Verify git repo
if [ ! -d "$MAIN_REPO/.git" ]; then
  echo "Error: Not a git repository: $MAIN_REPO" >&2
  exit 1
fi

# Determine worktree base path
${basePathLine}
WORKTREE_PATH="$WORKTREE_BASE/$WORKTREE_NAME"
BRANCH_NAME="\${BRANCH_PREFIX}\${WORKTREE_NAME}"

echo "Creating worktree at: $WORKTREE_PATH"

# Create worktree base directory
mkdir -p "$WORKTREE_BASE"

# Create git worktree with new branch
git -C "$MAIN_REPO" worktree add "$WORKTREE_PATH" -b "$BRANCH_NAME"

# Execute Claude in the worktree
cd "$WORKTREE_PATH"
echo "Executing Claude in: $WORKTREE_PATH"
CLAUDE_EXIT=0
${command} || CLAUDE_EXIT=$?

echo "Claude exited with code: $CLAUDE_EXIT"

# Commit and push changes
COMMIT_MSG="Claude task: $TASK_NAME [$TASK_ID]"
PUSHED=false
HAS_CHANGES=false

git add -A
if ! git diff --cached --quiet; then
  HAS_CHANGES=true
  git commit -m "$COMMIT_MSG"
  if git push -u "$REMOTE" "$BRANCH_NAME"; then
    PUSHED=true
    echo "Changes pushed to $REMOTE/$BRANCH_NAME"
  else
    echo "Warning: Failed to push changes" >&2
  fi
else
  echo "No changes to commit"
fi

# Cleanup: remove worktree if push succeeded or no changes
if [ "$PUSHED" = "true" ] || [ "$HAS_CHANGES" = "false" ]; then
  echo "Cleaning up worktree..."
  cd "$MAIN_REPO"
  git worktree remove "$WORKTREE_PATH" --force || true
  echo "Worktree removed"
else
  echo "Keeping worktree at $WORKTREE_PATH for manual review (push failed)"
fi

exit $CLAUDE_EXIT
`;
  }
}

/**
 * Error thrown when scheduler operations fail
 */
export class SchedulerError extends Error {
  public readonly platform: string;
  public readonly operation: string;
  public override readonly cause?: Error;

  constructor(
    message: string,
    platform: string,
    operation: string,
    cause?: Error
  ) {
    super(message);
    this.name = 'SchedulerError';
    this.platform = platform;
    this.operation = operation;
    this.cause = cause;
  }
}
